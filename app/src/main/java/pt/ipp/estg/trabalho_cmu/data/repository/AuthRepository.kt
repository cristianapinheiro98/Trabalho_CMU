package pt.ipp.estg.trabalho_cmu.data.repository

import android.content.Context
import com.google.firebase.firestore.FirebaseFirestore
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.tasks.await
import kotlinx.coroutines.withContext
import pt.ipp.estg.trabalho_cmu.R
import pt.ipp.estg.trabalho_cmu.data.local.dao.ShelterDao
import pt.ipp.estg.trabalho_cmu.data.local.dao.UserDao
import pt.ipp.estg.trabalho_cmu.data.local.entities.Shelter
import pt.ipp.estg.trabalho_cmu.data.local.entities.User
import pt.ipp.estg.trabalho_cmu.data.models.LoginResult
import pt.ipp.estg.trabalho_cmu.data.models.enums.AccountType
import pt.ipp.estg.trabalho_cmu.data.models.mappers.toFirebaseMap
import pt.ipp.estg.trabalho_cmu.data.models.mappers.toShelter
import pt.ipp.estg.trabalho_cmu.data.models.mappers.toUser
import pt.ipp.estg.trabalho_cmu.providers.FirebaseProvider
import pt.ipp.estg.trabalho_cmu.utils.NetworkUtils
import pt.ipp.estg.trabalho_cmu.utils.StringHelper

/**
 * Repository responsible for handling all authentication-related operations.
 *
 * Responsibilities:
 * - Registering users and shelters in Firebase Authentication.
 * - Storing profile data in Firestore.
 * - Syncing authenticated profiles into the local Room database.
 * - Logging in existing accounts (user or shelter).
 * - Restoring existing authenticated sessions, both online and offline.
 * - Providing access to the currently authenticated Firebase UID.
 *
 * This repository uses:
 * - FirebaseAuth for credential-based authentication
 * - Firestore for profile storage
 * - Room DAOs for offline persistence
 *
 * @param appContext Needed for retrieving localized strings.
 * @param userDao DAO for caching user profiles locally.
 * @param shelterDao DAO for caching shelter profiles locally.
 */
class AuthRepository(
    private val appContext: Context,
    private val userDao: UserDao,
    private val shelterDao: ShelterDao
) {

    private val firebaseAuth = FirebaseProvider.auth
    private val firestore: FirebaseFirestore = FirebaseProvider.firestore


    /**
     * Registers a regular user account (USER type).
     *
     * Steps:
     * 1. Ensures that an internet connection exists; registration requires online access.
     * 2. Creates a Firebase Authentication account using email/password.
     * 3. Retrieves the generated UID.
     * 4. Builds a User object and converts it to a Firestore-compatible map.
     * 5. Stores the user profile inside the "users" Firestore collection.
     * 6. Returns the created User model.
     *
     * Errors:
     * - Network unavailable.
     * - Firebase registration failure.
     * - Missing or invalid UID.
     *
     * @return Result<User> containing either the created user or an error.
     */
    suspend fun registerUser(
        name: String,
        address: String,
        phone: String,
        email: String,
        password: String
    ): Result<User> = withContext(Dispatchers.IO) {

        if (!NetworkUtils.isConnected()) {
            return@withContext Result.failure(
                Exception(StringHelper.getString(appContext, R.string.error_register_requires_internet))
            )
        }

        return@withContext try {
            val authResult = firebaseAuth
                .createUserWithEmailAndPassword(email, password)
                .await()

            val uid = authResult.user?.uid
                ?: throw Exception(StringHelper.getString(appContext, R.string.error_uid))

            val user = User(uid, name, address, email, phone)
            val userData = user.toFirebaseMap().toMutableMap()
            userData["accountType"] = "USER"

            firestore.collection("users")
                .document(uid)
                .set(userData)
                .await()

            Result.success(user)

        } catch (e: Exception) {
            Result.failure(e)
        }
    }

    /**
     * Registers a shelter account (SHELTER type).
     *
     * Steps:
     * 1. Validates that an internet connection is available.
     * 2. Creates a Firebase Authentication account.
     * 3. Retrieves the UID generated by Firebase.
     * 4. Constructs a Shelter entity and converts it to a Firestore map.
     * 5. Stores the profile in the "shelters" Firestore collection.
     *
     * This method mirrors registerUser(...) but stores data in a separate collection
     * and uses a different entity type.
     *
     * @return Result<Shelter> with the created shelter entity or an error.
     */

    suspend fun registerShelter(
        name: String,
        address: String,
        contact: String,
        email: String,
        password: String
    ): Result<Shelter> = withContext(Dispatchers.IO) {

        if (!NetworkUtils.isConnected()) {
            return@withContext Result.failure(
                Exception(StringHelper.getString(appContext, R.string.error_register_requires_internet))
            )
        }

        return@withContext try {
            val authResult = firebaseAuth
                .createUserWithEmailAndPassword(email, password)
                .await()

            val uid = authResult.user?.uid
                ?: throw Exception(StringHelper.getString(appContext, R.string.error_uid))

            val shelter = Shelter(uid, name, address, contact, email)
            val shelterData = shelter.toFirebaseMap().toMutableMap()
            shelterData["accountType"] = "SHELTER"

            firestore.collection("shelters")
                .document(uid)
                .set(shelterData)
                .await()

            Result.success(shelter)

        } catch (e: Exception) {
            Result.failure(e)
        }
    }

    /**
     * Attempts to authenticate an existing account using email and password.
     *
     * Workflow:
     * 1. Requires an active internet connection.
     * 2. Authenticates with FirebaseAuth.
     * 3. Retrieves the UID of the logged-in account.
     * 4. Checks Firestore for a matching "users" document:
     *      → If found, converts to User and caches it locally in Room.
     * 5. If not found, checks "shelters":
     *      → If found, converts to Shelter and caches it locally.
     * 6. Returns a LoginResult indicating the account type (USER or SHELTER).
     *
     * Errors:
     * - Invalid credentials.
     * - User not found in either Firestore collection.
     *
     * @return Result<LoginResult> with user/shelter profile and account type.
     */

    suspend fun login(email: String, password: String): Result<LoginResult> =
        withContext(Dispatchers.IO) {

            if (!NetworkUtils.isConnected()) {
                return@withContext Result.failure(
                    Exception(StringHelper.getString(appContext, R.string.error_login_requires_internet))
                )
            }

            return@withContext try {
                val authResult = firebaseAuth
                    .signInWithEmailAndPassword(email, password)
                    .await()

                val uid = authResult.user?.uid
                    ?: throw Exception(StringHelper.getString(appContext, R.string.error_uid_not_found))

                // ------------------ USER ------------------
                val userDoc = firestore.collection("users").document(uid).get().await()
                if (userDoc.exists()) {
                    val user = userDoc.toUser()!!.copy(id = uid)
                    userDao.insert(user)
                    return@withContext Result.success(
                        LoginResult(user = user, accountType = AccountType.USER)
                    )
                }

                // ------------------ SHELTER ------------------
                val shelterDoc = firestore.collection("shelters").document(uid).get().await()
                if (shelterDoc.exists()) {
                    val shelter = shelterDoc.toShelter()!!.copy(id = uid)
                    shelterDao.insert(shelter)
                    return@withContext Result.success(
                        LoginResult(shelter = shelter, accountType = AccountType.SHELTER)
                    )
                }

                throw Exception(StringHelper.getString(appContext, R.string.error_account_not_found))

            } catch (e: Exception) {
                Result.failure(e)
            }
        }


    /**
     * Restores the current authenticated session, supporting both offline and online modes.
     *
     * Behavior Offline:
     * - If FirebaseAuth has a cached UID but no connectivity,
     *   attempts to restore the profile from the local Room database.
     * - Returns a LoginResult constructed from cached entities, if available.
     *
     * Behavior Online:
     * - Forces token refresh using getIdToken(true).
     * - Fetches the profile again from Firestore.
     * - Updates Room with the latest data.
     *
     * If the profile does not exist in Firestore anymore:
     * - Returns null (session no longer valid).
     *
     * Errors:
     * - Firestore or token refresh failures.
     *
     * @return Result<LoginResult?> where:
     *         - success(null) means no logged-in session exists.
     *         - success(LoginResult) restores the session.
     */
    suspend fun checkSession(): Result<LoginResult?> = withContext(Dispatchers.IO) {

        val uid = firebaseAuth.currentUser?.uid ?: return@withContext Result.success(null)

        if (!NetworkUtils.isConnected()) {

            val localUser = userDao.getUserById(uid)
            if (localUser != null) {
                return@withContext Result.success(
                    LoginResult(user = localUser, accountType = AccountType.USER)
                )
            }

            val localShelter = shelterDao.getShelterById(uid)
            if (localShelter != null) {
                return@withContext Result.success(
                    LoginResult(shelter = localShelter, accountType = AccountType.SHELTER)
                )
            }

            return@withContext Result.success(null)
        }

        return@withContext try {
            firebaseAuth.currentUser?.getIdToken(true)?.await()

            val userDoc = firestore.collection("users").document(uid).get().await()
            if (userDoc.exists()) {
                val user = userDoc.toUser()!!.copy(id = uid)
                userDao.insert(user)
                return@withContext Result.success(
                    LoginResult(user = user, accountType = AccountType.USER)
                )
            }

            val shelterDoc = firestore.collection("shelters").document(uid).get().await()
            if (shelterDoc.exists()) {
                val shelter = shelterDoc.toShelter()!!.copy(id = uid)
                shelterDao.insert(shelter)
                return@withContext Result.success(
                    LoginResult(shelter = shelter, accountType = AccountType.SHELTER)
                )
            }

            Result.success(null)

        } catch (e: Exception) {
            firebaseAuth.signOut()
            Result.failure(e)
        }
    }

    /**
     * Logs out the current Firebase user.
     *
     * This clears the authentication token but does not delete cached
     * Room data. Local profiles may still exist for offline reading.
     */

    fun logout() = firebaseAuth.signOut()

    /**
     * @return The UID of the currently authenticated Firebase user, or null if not logged in.
     */

    fun getCurrentUserId() = firebaseAuth.currentUser?.uid
}
